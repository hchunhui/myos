#include <type.h>
#include <klib.h>
#include <task.h>
#include <protect.h>
#include <string.h>
#include <io.h>

struct s_desc gdt[16];
b16 gdt_48[3];
struct s_gate idt[256];
b16 idt_48[3];
struct s_tss tss;		//整个内核只用这一个tss

void divide_error();
void single_step_exception();
void nmi();
void breakpoint_exception();
void overflow();
void bounds_check();
void inval_opcode();
void copr_not_available();
void double_fault();
void copr_seg_overrun();
void inval_tss();
void segment_not_present();
void stack_exception();
void general_protection();
void page_fault();
void untitled();
void copr_error();
//中断处理程序
void hwint00();
void hwint01();
void hwint02();
void hwint03();
void hwint04();
void hwint05();
void hwint06();
void hwint07();
void hwint08();
void hwint09();
void hwint10();
void hwint11();
void hwint12();
void hwint13();
void hwint14();
void hwint15();

//系统调用
void sys_call();

static void set_idt_desc(b8 vector,b8 desc_type,void* handler,b8 privilege)
{
	struct s_gate *p_gate;
	p_gate=&idt[vector];
	b32 base=(b32)handler;

	p_gate->offsetL  = base & 0xFFFF;
	p_gate->selector = CS;
	p_gate->dcount   = 0;
	p_gate->attr     = desc_type | (privilege<<5);
	p_gate->offsetH  = (base>>16) & 0xFFFF;
}

static void set_gdt_desc(b8 vector, b32 base, b32 limit, b16 attribute)		//from sgos
{
	struct s_desc* pDesc	= &gdt[vector];
	pDesc->limitL		= limit & 0x0FFFF;		// 段界限 1		(2 字节)
	pDesc->baseL		= base & 0x0FFFF;		// 段基址 1		(2 字节)
	pDesc->baseHL		= (base >> 16) & 0x0FF;		// 段基址 2		(1 字节)
	pDesc->attr1			= attribute & 0xFF;		// 属性 1
	pDesc->limitH_attr2	= ((limit >> 16) & 0x0F) | ((attribute >> 8) & 0xF0); // 段界限 2 + 属性 2
	pDesc->baseHH		= (base >> 24) & 0x0FF;		// 段基址 3		(1 字节)
}

static void make_gdt_desc()
{
	set_gdt_desc(0,0,0,0);
	set_gdt_desc(1,0x0,0xFFFFF,DA_CR|DA_32|DA_LIMIT_4K);	// 32位代码段		段限0xFFFFF*4kb=4GB
	set_gdt_desc(2,0x0,0xFFFFF,DA_DRW|DA_LIMIT_4K|DA_32);					// 可读写数据段	段限4GB
	set_gdt_desc(3,0x0,0xFFFFF,DA_CR|DA_LIMIT_4K|DA_32|DA_DPL3);	//ring3
	set_gdt_desc(4,0x0,0xFFFFF,DA_DRW|DA_LIMIT_4K|DA_32|DA_DPL3);	
	set_gdt_desc(5,(b32)&tss,sizeof(struct s_tss)-1,DA_386TSS);			//tss
	set_gdt_desc(6,0x0,0xFFFFF,DA_C);
	set_gdt_desc(7,0x0,0xFFFFF,DA_DRW);
	set_gdt_desc(8,0x0,0xFFFFF,DA_CR|DA_32|DA_LIMIT_4K|DA_DPL1);	//ring1
	set_gdt_desc(9,0x0,0xFFFFF,DA_DRW|DA_32|DA_LIMIT_4K|DA_DPL1);
	//init gdt_48
	gdt_48[0]=10*sizeof(struct s_desc)-1;
	gdt_48[1]=((b32)gdt)&0xffff;
	gdt_48[2]=((b32)gdt)>>16;
	/* something */	
}

static void reset_gdt()
{
	//update
	asm volatile(
	"lgdt %0\n\t"
	"ljmp $0x8,$1f\n"
	"1:\tmovw $0x10,%%ax\n\t"
	"movw %%ax,%%ds\n\t"
	"movw %%ax,%%es\n\t"
	"movw %%ax,%%fs\n\t"
	"movw %%ax,%%gs\n\t"
	:"=m"(gdt_48)			//why??
	);
}

static void make_idt_desc()
{
     //exception
	set_idt_desc(0,DA_386IGate,divide_error,PRIVILEGE_KNL);
	set_idt_desc(1,DA_386IGate,single_step_exception,PRIVILEGE_KNL);
	set_idt_desc(2,DA_386IGate,nmi,PRIVILEGE_KNL);
	set_idt_desc(3,DA_386IGate,breakpoint_exception,PRIVILEGE_USER);
	set_idt_desc(4,DA_386IGate,overflow,PRIVILEGE_USER);
	set_idt_desc(5,DA_386IGate,bounds_check,PRIVILEGE_USER);
	set_idt_desc(6,DA_386IGate,inval_opcode,PRIVILEGE_KNL);
	set_idt_desc(7,DA_386IGate,copr_not_available,PRIVILEGE_KNL);
	set_idt_desc(8,DA_386IGate,double_fault,PRIVILEGE_KNL);
	set_idt_desc(9,DA_386IGate,copr_seg_overrun,PRIVILEGE_KNL);
	set_idt_desc(10,DA_386IGate,inval_tss,PRIVILEGE_KNL);
	set_idt_desc(11,DA_386IGate,segment_not_present,PRIVILEGE_KNL);
	set_idt_desc(12,DA_386IGate,stack_exception,PRIVILEGE_KNL);
	set_idt_desc(13,DA_386IGate,general_protection,PRIVILEGE_KNL);
	set_idt_desc(14,DA_386IGate,page_fault,PRIVILEGE_KNL);
	set_idt_desc(15,DA_386IGate,untitled,PRIVILEGE_KNL);
	set_idt_desc(16,DA_386IGate,copr_error,PRIVILEGE_KNL);
	//hwint
	set_idt_desc(IRQ_0,DA_386IGate,hwint00,PRIVILEGE_KNL);
	set_idt_desc(IRQ_0+1,DA_386IGate,hwint01,PRIVILEGE_KNL);
	set_idt_desc(IRQ_0+2,DA_386IGate,hwint02,PRIVILEGE_KNL);
	set_idt_desc(IRQ_0+3,DA_386IGate,hwint03,PRIVILEGE_KNL);
	set_idt_desc(IRQ_0+4,DA_386IGate,hwint04,PRIVILEGE_KNL);
	set_idt_desc(IRQ_0+5,DA_386IGate,hwint05,PRIVILEGE_KNL);
	set_idt_desc(IRQ_0+6,DA_386IGate,hwint06,PRIVILEGE_KNL);
	set_idt_desc(IRQ_0+7,DA_386IGate,hwint07,PRIVILEGE_KNL);
	set_idt_desc(IRQ_8,DA_386IGate,hwint08,PRIVILEGE_KNL);
	set_idt_desc(IRQ_8+1,DA_386IGate,hwint09,PRIVILEGE_KNL);
	set_idt_desc(IRQ_8+2,DA_386IGate,hwint10,PRIVILEGE_KNL);
	set_idt_desc(IRQ_8+3,DA_386IGate,hwint11,PRIVILEGE_KNL);
	set_idt_desc(IRQ_8+4,DA_386IGate,hwint12,PRIVILEGE_KNL);
	set_idt_desc(IRQ_8+5,DA_386IGate,hwint13,PRIVILEGE_KNL);
	set_idt_desc(IRQ_8+6,DA_386IGate,hwint14,PRIVILEGE_KNL);
	set_idt_desc(IRQ_8+7,DA_386IGate,hwint15,PRIVILEGE_KNL);
	//sys_call
	set_idt_desc(SYSCALL,DA_386IGate,sys_call,PRIVILEGE_USER);

	//idt_48
	idt_48[0]=256*sizeof(struct s_gate)-1;
	idt_48[1]=((b32)idt)&0xffff;
	idt_48[2]=((b32)idt)>>16;
}

static void set_idt()
{
	//load
	asm volatile ( "lidt %0" : "=m"( idt_48 ) );		//why?
	//asm volatile ("sti");		//启动进程后会自动打开的
}

static void init_8259A()
{
	outb_p(0x11, I8259M);				//ICW1    00010001b
	outb_p(0x11, I8259S);
	outb_p(IRQ_0, I8259MMask);			//ICW2    IRQ0-->0x20
	outb_p(IRQ_8, I8259SMask);			//        IRQ8-->0x28
	outb_p(0x4, I8259MMask);			//主ICW3  主IR2接从  100b
	outb_p(0x2, I8259SMask);			//从      从接主IR2
	outb_p(0x1, I8259MMask);			//ICW4
	outb_p(0x1, I8259SMask);

	outb_p(0xff, I8259MMask);			//OCW1 关闭了所有中断
	outb_p(0xff, I8259SMask);
}


/* realmode.S 专用接口 */
static u8 i8259_s1,i8259_s2;
void pm_pre_reinit()
{
	i8259_s1=inb(I8259MMask);
	i8259_s2=inb(I8259SMask);
}

void mm_reinit();
void pm_reinit()
{
	reset_gdt();
	init_8259A();
	outb(i8259_s1, I8259MMask);
	outb(i8259_s2, I8259SMask);
	set_idt();
	mm_reinit();
	inb(0x60);
	inb(0x60);
	inb(0x60);
	inb(0x60);
}
/* realmode.S 专用接口 */

void pm_setup_real_code();	//in realmode.S
void pm_init()
{
	make_gdt_desc();
	make_idt_desc();
	reset_gdt();
	init_8259A();
	set_idt();
	pm_setup_real_code();
	printk("protect mode init ok.\n");
}

void pm_enable_irq(b32 irq)
{
	if(irq<8)
	{
		outb(inb(I8259MMask)&(~(1<<irq)), I8259MMask);
	}
	else
	{
		outb(inb(I8259MMask)&(~(1<<2)), I8259MMask);
		outb(inb(I8259SMask)&(~(1<<(irq-8))), I8259SMask);
	}
}
